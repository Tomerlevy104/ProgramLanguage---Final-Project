from parser import *
from general import *
from lexer import my_Lexer
import sys
#######################################
# function
#######################################

# The Function class represents a callable function in the @ language.
# It stores the function's name, body, arguments, and context information.
# The execute method handles the function call process, including argument validation,
# setting up a new execution context, and interpreting the function body.


class Function:
    def __init__(self, name, body_node, arg_names, parent_context, global_symbol_table):
        self.name = name
        self.body_node = body_node
        self.arg_names = arg_names
        self.parent_context = parent_context
        self.global_symbol_table = global_symbol_table

    def execute(self, args):
        res = RTResult()
        interpreter = Interpreter(self.global_symbol_table.copy())
        new_context = Context(self.name, self.parent_context)

        if len(args) != len(self.arg_names):
            return res.failure(RTError(
                self.body_node.pos_start, self.body_node.pos_end,
                f"{len(self.arg_names)} arguments expected, got {len(args)}",
                self.parent_context
            ))

        for i in range(len(args)):
            arg_name = self.arg_names[i]
            arg_value = args[i]
            interpreter.global_symbol_table[arg_name] = arg_value

        interpreter.context = new_context
        value = res.register(interpreter.visit(self.body_node))
        if res.error: return res
        return res.success(value)

#######################################
# context
#######################################

# The Context class represents the execution context for a specific scope in the @ language.
# It maintains information about the current scope's name, its parent context, and the position
# where it was entered. This class is crucial for managing nested scopes and proper variable resolution.


class Context:
    def __init__(self, display_name, parent=None, parent_entry_pos=None):
        self.display_name = display_name
        self.parent = parent
        self.parent_entry_pos = parent_entry_pos
        self.symbol_table = None

#######################################
# INTERPRETER
#######################################

# The RTResult (Runtime Result) class is used to handle the results of runtime operations.
# It encapsulates both successful results (values) and errors that may occur during interpretation.
# This class helps in propagating results and errors through the interpretation process,
# allowing for clean error handling and result management throughout the interpreter.

class RTResult:
    def __init__(self):
        self.value = None
        self.error = None

    def register(self, res):
        if isinstance(res, RTResult):
            if res.error: self.error = res.error
            return res.value
        return res

    def success(self, value):
        self.value = value
        return self

    def failure(self, error):
        self.error = error
        return self


# The Interpreter class is responsible for executing the Abstract Syntax Tree (AST) generated by the parser.
# It implements the visitor pattern to traverse the AST and execute each node according to the language semantics.
# This class handles runtime operations, function calls, variable assignments, and expression evaluations.
# It also manages the global symbol table and execution context, ensuring proper scoping and variable resolution.

class Interpreter:
    def __init__(self, global_symbol_table):
        self.global_symbol_table = global_symbol_table
        self.context = Context('<program>')

    def visit(self, node):
        method_name = f'visit_{type(node).__name__}'
        method = getattr(self, method_name, self.no_visit_method)
        return method(node)

    def visit_FunctionDefNode(self, node):
        res = RTResult()
        func_name = node.name_tok.value
        body_node = node.body_node
        arg_names = [arg_tok.value for arg_tok in node.arg_name_toks]
        func_value = Function(func_name, body_node, arg_names, self.context, self.global_symbol_table)

        self.global_symbol_table[func_name] = func_value
        return res.success(f"Function '{func_name}' defined successfully")

    def visit_FunctionCallNode(self, node):
        res = RTResult()
        args = []

        if isinstance(node.name_tok, LambdaNode):
            func_value = res.register(self.visit_LambdaNode(node.name_tok))
        elif isinstance(node.name_tok, IdentifierNode):
            func_value = self.global_symbol_table.get(node.name_tok.tok.value)
        else:
            func_value = res.register(self.visit(node.name_tok))

        if res.error:
            return res

        if not func_value:
            return res.failure(RTError(
                node.pos_start, node.pos_end,
                f"'{node.name_tok.tok.value if isinstance(node.name_tok, IdentifierNode) else '<anonymous>'}'  is not defined",
                self.context
            ))

        for arg_node in node.arg_nodes:
            args.append(res.register(self.visit(arg_node)))
            if res.error: return res

        return_value = res.register(func_value.execute(args))
        if res.error: return res
        return res.success(return_value)

    def visit_IdentifierNode(self, node):
        var_name = node.tok.value
        value = self.global_symbol_table.get(var_name)

        if value is None:
            return RTResult().failure(RTError(
                node.pos_start, node.pos_end,
                f"'{var_name}' is not defined",
                self.context
            ))

        return RTResult().success(value)

    def no_visit_method(self, node):
        raise Exception(f'No visit_{type(node).__name__} method')

    def visit_NumberNode(self, node):
        return RTResult().success(node.tok.value)

    def visit_BooleanNode(self, node):
        return RTResult().success(node.tok.value)

    def visit_BinOpNode(self, node):
        res = RTResult()
        result = None
        left = res.register(self.visit(node.left_node))
        if res.error: return res
        right = res.register(self.visit(node.right_node))
        if res.error: return res

        if node.op_tok.type == T_DIV:
            if right == 0:
                pos_start = node.op_tok.pos_start if node.op_tok.pos_start else node.left_node.pos_start
                pos_end = node.op_tok.pos_end if node.op_tok.pos_end else node.right_node.pos_end
                return res.failure(DivisionByZeroError(
                    pos_start, pos_end
                ))
            result = left // right
        elif node.op_tok.type == T_PLUS:
            result = left + right
        elif node.op_tok.type == T_SUB:
            result = left - right
        elif node.op_tok.type == T_MUL:
            result = left * right
        elif node.op_tok.type == T_MODULO:
            result = left % right
        elif node.op_tok.type == T_EQEQ:
            result = left == right
        elif node.op_tok.type == T_NEQ:
            result = left != right
        elif node.op_tok.type == T_GREATERTHAN:
            result = left > right
        elif node.op_tok.type == T_LESSTHAN:
            result = left < right
        elif node.op_tok.type == T_EQGREATERTHAN:
            result = left >= right
        elif node.op_tok.type == T_EQLESSTHAN:
            result = left <= right
        elif node.op_tok.type == T_AND:
            result = left if not left else right
        elif node.op_tok.type == T_OR:
            result = left if left else right

        return res.success(result)

    def visit_UnaryOpNode(self, node):
        res = RTResult()
        value = res.register(self.visit(node.node))
        if res.error: return res

        if node.op_tok.type == T_NOT:
            value = not value
        elif node.op_tok.type == T_SUB:
            value = -value

        return res.success(value)

    def visit_IfNode(self, node):
        res = RTResult()

        for condition, expr in node.cases:
            condition_value = res.register(self.visit(condition))
            if res.error: return res

            if condition_value:
                return res.success(res.register(self.visit(expr)))

        if node.else_case:
            return res.success(res.register(self.visit(node.else_case)))

        return res.success(None)

    def visit_ForNode(self, node):
        res = RTResult()
        results = []

        start_value = res.register(self.visit(node.start_value_node))
        if res.error: return res

        end_value = res.register(self.visit(node.end_value_node))
        if res.error: return res

        if node.step_value_node:
            step_value = res.register(self.visit(node.step_value_node))
            if res.error: return res
        else:
            step_value = 1

        i = start_value

        while i < end_value:
            self.global_symbol_table[node.var_name_tok.value] = i

            value = res.register(self.visit(node.body_node))
            if res.error: return res

            results.append(value)
            i += step_value

        return res.success(results)

    def visit_LambdaNode(self, node):
        res = RTResult()

        func_name = f"<lambda_{id(node)}>"
        body_node = node.body_node
        arg_names = [arg_tok.value for arg_tok in node.arg_name_toks]
        func_value = Function(func_name, body_node, arg_names, self.context, self.global_symbol_table)

        return res.success(func_value)

#######################################
# RUN
#######################################


global_symbol_table = {}


def run(fn, text):
    # Generate tokens
    lexer = my_Lexer(fn, text)
    tokens, error = lexer.make_tokens()
    if error:
        return None, error
    # Parsing
    parser = Parser(tokens)
    ast = parser.parse()
    if ast.error: return None, ast.error

    # Interpreting
    interpreter = Interpreter(global_symbol_table)
    result = interpreter.visit(ast.node)

    return result.value, result.error


def main():
    if len(sys.argv) == 2:
        # File mode
        filename = sys.argv[1]
        run_file(filename)
    else:
        # REPL mode
        run_repl()


def run_file(filename):
    with open(filename, 'r') as file:
        lines = file.readlines()

    for i, line in enumerate(lines):
        line = line.strip()
        if line == '':
            continue  # Skip empty lines
        print(f"Line {i+1}: {line}")
        result, error = run(filename, line)
        if error:
            print(f"Error: {error.as_string()}\n")
        else:
            print(f"Output: {result}\n")


def run_repl():
    print("Starting REPL... Type 'exit' to quit.")
    while True:
        try:
            text = input('basic > ')
            if text.strip().lower() == 'exit':
                print("\nExiting REPL...")
                break
            result, error = run('<stdin>', text)
            if error:
                print(error.as_string())
            else:
                print(result)
        except KeyboardInterrupt:
            print("\nExiting REPL...")
            break


if __name__ == '__main__':
    main()

